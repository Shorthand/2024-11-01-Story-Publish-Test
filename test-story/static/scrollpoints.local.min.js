(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../node_modules/.pnpm/fastdom@1.0.12/node_modules/fastdom/fastdom.js
  var require_fastdom = __commonJS({
    "../node_modules/.pnpm/fastdom@1.0.12/node_modules/fastdom/fastdom.js"(exports, module) {
      !function(win) {
        "use strict";
        var debug = 0 ? console.log.bind(console, "[fastdom]") : function() {
        };
        var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function(cb) {
          return setTimeout(cb, 16);
        };
        function FastDom() {
          var self = this;
          self.reads = [];
          self.writes = [];
          self.raf = raf.bind(win);
          debug("initialized", self);
        }
        FastDom.prototype = {
          constructor: FastDom,
          /**
           * We run this inside a try catch
           * so that if any jobs error, we
           * are able to recover and continue
           * to flush the batch until it's empty.
           *
           * @param {Array} tasks
           */
          runTasks: function(tasks) {
            debug("run tasks");
            var task;
            while (task = tasks.shift())
              task();
          },
          /**
           * Adds a job to the read batch and
           * schedules a new frame if need be.
           *
           * @param  {Function} fn
           * @param  {Object} ctx the context to be bound to `fn` (optional).
           * @public
           */
          measure: function(fn, ctx) {
            debug("measure");
            var task = !ctx ? fn : fn.bind(ctx);
            this.reads.push(task);
            scheduleFlush(this);
            return task;
          },
          /**
           * Adds a job to the
           * write batch and schedules
           * a new frame if need be.
           *
           * @param  {Function} fn
           * @param  {Object} ctx the context to be bound to `fn` (optional).
           * @public
           */
          mutate: function(fn, ctx) {
            debug("mutate");
            var task = !ctx ? fn : fn.bind(ctx);
            this.writes.push(task);
            scheduleFlush(this);
            return task;
          },
          /**
           * Clears a scheduled 'read' or 'write' task.
           *
           * @param {Object} task
           * @return {Boolean} success
           * @public
           */
          clear: function(task) {
            debug("clear", task);
            return remove(this.reads, task) || remove(this.writes, task);
          },
          /**
           * Extend this FastDom with some
           * custom functionality.
           *
           * Because fastdom must *always* be a
           * singleton, we're actually extending
           * the fastdom instance. This means tasks
           * scheduled by an extension still enter
           * fastdom's global task queue.
           *
           * The 'super' instance can be accessed
           * from `this.fastdom`.
           *
           * @example
           *
           * var myFastdom = fastdom.extend({
           *   initialize: function() {
           *     // runs on creation
           *   },
           *
           *   // override a method
           *   measure: function(fn) {
           *     // do extra stuff ...
           *
           *     // then call the original
           *     return this.fastdom.measure(fn);
           *   },
           *
           *   ...
           * });
           *
           * @param  {Object} props  properties to mixin
           * @return {FastDom}
           */
          extend: function(props) {
            debug("extend", props);
            if (typeof props != "object")
              throw new Error("expected object");
            var child = Object.create(this);
            mixin(child, props);
            child.fastdom = this;
            if (child.initialize)
              child.initialize();
            return child;
          },
          // override this with a function
          // to prevent Errors in console
          // when tasks throw
          catch: null
        };
        function scheduleFlush(fastdom2) {
          if (!fastdom2.scheduled) {
            fastdom2.scheduled = true;
            fastdom2.raf(flush.bind(null, fastdom2));
            debug("flush scheduled");
          }
        }
        function flush(fastdom2) {
          debug("flush");
          var writes = fastdom2.writes;
          var reads = fastdom2.reads;
          var error;
          try {
            debug("flushing reads", reads.length);
            fastdom2.runTasks(reads);
            debug("flushing writes", writes.length);
            fastdom2.runTasks(writes);
          } catch (e) {
            error = e;
          }
          fastdom2.scheduled = false;
          if (reads.length || writes.length)
            scheduleFlush(fastdom2);
          if (error) {
            debug("task errored", error.message);
            if (fastdom2.catch)
              fastdom2.catch(error);
            else
              throw error;
          }
        }
        function remove(array, item) {
          var index = array.indexOf(item);
          return !!~index && !!array.splice(index, 1);
        }
        function mixin(target, source) {
          for (var key in source) {
            if (source.hasOwnProperty(key))
              target[key] = source[key];
          }
        }
        var exports2 = win.fastdom = win.fastdom || new FastDom();
        if (false)
          (void 0)(function() {
            return exports2;
          });
        else if (typeof module == "object")
          module.exports = exports2;
      }(typeof window !== "undefined" ? window : typeof exports != "undefined" ? exports : globalThis);
    }
  });

  // ../node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/dedupe.js
  var require_dedupe = __commonJS({
    "../node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/dedupe.js"(exports, module) {
      (function() {
        "use strict";
        var classNames = function() {
          function StorageObject() {
          }
          StorageObject.prototype = /* @__PURE__ */ Object.create(null);
          function _parseArray(resultSet, array) {
            var length = array.length;
            for (var i = 0; i < length; ++i) {
              _parse(resultSet, array[i]);
            }
          }
          var hasOwn = {}.hasOwnProperty;
          function _parseNumber(resultSet, num) {
            resultSet[num] = true;
          }
          function _parseObject(resultSet, object) {
            if (object.toString !== Object.prototype.toString && !object.toString.toString().includes("[native code]")) {
              resultSet[object.toString()] = true;
              return;
            }
            for (var k in object) {
              if (hasOwn.call(object, k)) {
                resultSet[k] = !!object[k];
              }
            }
          }
          var SPACE = /\s+/;
          function _parseString(resultSet, str) {
            var array = str.split(SPACE);
            var length = array.length;
            for (var i = 0; i < length; ++i) {
              resultSet[array[i]] = true;
            }
          }
          function _parse(resultSet, arg) {
            if (!arg)
              return;
            var argType = typeof arg;
            if (argType === "string") {
              _parseString(resultSet, arg);
            } else if (Array.isArray(arg)) {
              _parseArray(resultSet, arg);
            } else if (argType === "object") {
              _parseObject(resultSet, arg);
            } else if (argType === "number") {
              _parseNumber(resultSet, arg);
            }
          }
          function _classNames() {
            var len = arguments.length;
            var args = Array(len);
            for (var i = 0; i < len; i++) {
              args[i] = arguments[i];
            }
            var classSet = new StorageObject();
            _parseArray(classSet, args);
            var list = [];
            for (var k in classSet) {
              if (classSet[k]) {
                list.push(k);
              }
            }
            return list.join(" ");
          }
          return _classNames;
        }();
        if (typeof module !== "undefined" && module.exports) {
          classNames.default = classNames;
          module.exports = classNames;
        } else if (false) {
          (void 0)("classnames", [], function() {
            return classNames;
          });
        } else {
          window.classNames = classNames;
        }
      })();
    }
  });

  // ../node_modules/.pnpm/sniffr@1.2.0/node_modules/sniffr/src/sniffr.js
  var require_sniffr = __commonJS({
    "../node_modules/.pnpm/sniffr@1.2.0/node_modules/sniffr/src/sniffr.js"(exports, module) {
      (function(host) {
        var properties = {
          browser: [
            [/msie ([\.\_\d]+)/, "ie"],
            [/trident\/.*?rv:([\.\_\d]+)/, "ie"],
            [/firefox\/([\.\_\d]+)/, "firefox"],
            [/chrome\/([\.\_\d]+)/, "chrome"],
            [/version\/([\.\_\d]+).*?safari/, "safari"],
            [/mobile safari ([\.\_\d]+)/, "safari"],
            [/android.*?version\/([\.\_\d]+).*?safari/, "com.android.browser"],
            [/crios\/([\.\_\d]+).*?safari/, "chrome"],
            [/opera/, "opera"],
            [/opera\/([\.\_\d]+)/, "opera"],
            [/opera ([\.\_\d]+)/, "opera"],
            [/opera mini.*?version\/([\.\_\d]+)/, "opera.mini"],
            [/opios\/([a-z\.\_\d]+)/, "opera"],
            [/blackberry/, "blackberry"],
            [/blackberry.*?version\/([\.\_\d]+)/, "blackberry"],
            [/bb\d+.*?version\/([\.\_\d]+)/, "blackberry"],
            [/rim.*?version\/([\.\_\d]+)/, "blackberry"],
            [/iceweasel\/([\.\_\d]+)/, "iceweasel"],
            [/edge\/([\.\d]+)/, "edge"]
          ],
          os: [
            [/linux ()([a-z\.\_\d]+)/, "linux"],
            [/mac os x/, "macos"],
            [/mac os x.*?([\.\_\d]+)/, "macos"],
            [/os ([\.\_\d]+) like mac os/, "ios"],
            [/openbsd ()([a-z\.\_\d]+)/, "openbsd"],
            [/android/, "android"],
            [/android ([a-z\.\_\d]+);/, "android"],
            [/mozilla\/[a-z\.\_\d]+ \((?:mobile)|(?:tablet)/, "firefoxos"],
            [/windows\s*(?:nt)?\s*([\.\_\d]+)/, "windows"],
            [/windows phone.*?([\.\_\d]+)/, "windows.phone"],
            [/windows mobile/, "windows.mobile"],
            [/blackberry/, "blackberryos"],
            [/bb\d+/, "blackberryos"],
            [/rim.*?os\s*([\.\_\d]+)/, "blackberryos"]
          ],
          device: [
            [/ipad/, "ipad"],
            [/iphone/, "iphone"],
            [/lumia/, "lumia"],
            [/htc/, "htc"],
            [/nexus/, "nexus"],
            [/galaxy nexus/, "galaxy.nexus"],
            [/nokia/, "nokia"],
            [/ gt\-/, "galaxy"],
            [/ sm\-/, "galaxy"],
            [/xbox/, "xbox"],
            [/(?:bb\d+)|(?:blackberry)|(?: rim )/, "blackberry"]
          ]
        };
        var UNKNOWN = "Unknown";
        var propertyNames = Object.keys(properties);
        function Sniffr2() {
          var self = this;
          propertyNames.forEach(function(propertyName) {
            self[propertyName] = {
              name: UNKNOWN,
              version: [],
              versionString: UNKNOWN
            };
          });
        }
        function determineProperty(self, propertyName, userAgent) {
          properties[propertyName].forEach(function(propertyMatcher) {
            var propertyRegex = propertyMatcher[0];
            var propertyValue = propertyMatcher[1];
            var match = userAgent.match(propertyRegex);
            if (match) {
              self[propertyName].name = propertyValue;
              if (match[2]) {
                self[propertyName].versionString = match[2];
                self[propertyName].version = [];
              } else if (match[1]) {
                self[propertyName].versionString = match[1].replace(/_/g, ".");
                self[propertyName].version = parseVersion(match[1]);
              } else {
                self[propertyName].versionString = UNKNOWN;
                self[propertyName].version = [];
              }
            }
          });
        }
        function parseVersion(versionString) {
          return versionString.split(/[\._]/).map(function(versionPart) {
            return parseInt(versionPart);
          });
        }
        Sniffr2.prototype.sniff = function(userAgentString) {
          var self = this;
          var isBrowser = typeof window !== "undefined";
          var fallbackUserAgent = isBrowser ? navigator.userAgent : "";
          var userAgent = (userAgentString || fallbackUserAgent).toLowerCase();
          propertyNames.forEach(function(propertyName) {
            determineProperty(self, propertyName, userAgent);
          });
          return this;
        };
        if (typeof module !== "undefined" && module.exports) {
          module.exports = Sniffr2;
        } else {
          host.Sniffr = new Sniffr2();
          host.Sniffr.sniff(navigator.userAgent);
        }
      })(exports);
    }
  });

  // ../node_modules/.pnpm/clamp@1.0.1/node_modules/clamp/index.js
  var require_clamp = __commonJS({
    "../node_modules/.pnpm/clamp@1.0.1/node_modules/clamp/index.js"(exports, module) {
      module.exports = clamp2;
      function clamp2(value, min, max) {
        return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
      }
    }
  });

  // ../story/src/core/globals.ts
  if (!window.hasOwnProperty("Shorthand")) {
    window.Shorthand = {};
  }

  // ../story/src/display-container/full-height-flex.ts
  var import_fastdom = __toESM(require_fastdom());

  // ../story/src/device-detect/index.ts
  var import_dedupe = __toESM(require_dedupe());
  var Sniffr = require_sniffr();

  // ../story/src/dom-helpers/query.ts
  function queryAll(selector, context = null) {
    const queryFrom = getContext(context);
    const nodeList = queryFrom.querySelectorAll(selector);
    return Array.from(nodeList);
  }
  function getContext(defaultContext) {
    if (defaultContext)
      return defaultContext;
    if (window["__shadowRoot"])
      return window["__shadowRoot"].querySelector("article");
    return document;
  }

  // ../story/src/display-container/index.ts
  var facade = {
    getOrientation() {
      if (!window.Shorthand.displayContainer) {
        return window.innerWidth > window.innerHeight ? "landscape" : "portrait";
      }
      return facade.getWidth() > facade.getHeight() ? "landscape" : "portrait";
    },
    getHeight() {
      return window.Shorthand.displayContainer.getCache().height;
    },
    getWidth() {
      return window.Shorthand.displayContainer.getCache().width;
    },
    getTop() {
      return window.Shorthand.displayContainer.getCache().top;
    },
    getBottom() {
      return window.Shorthand.displayContainer.getCache().bottom;
    },
    getVhUnitsInPixels(vhunits) {
      const oneHundredVhInPixels = facade.getHeight();
      return oneHundredVhInPixels * (vhunits / 100);
    },
    getDisplayContainer() {
      return window.Shorthand.displayContainer;
    }
  };
  var display_container_default = facade;

  // ../story/src/scrollpoints/Camera.ts
  var import_clamp = __toESM(require_clamp());

  // ../story/src/scrollpoints/utils.ts
  function round(v) {
    if (typeof v === "number")
      return Math.round(v);
    return {
      x: round(v.x),
      y: round(v.y),
      // Zoom component can't be rounded
      z: v.z
    };
  }
  function getDefaultStyle() {
    return {
      noHighlightsBehaviour: "contain",
      lineWidth: 10,
      lineColor: "#12bf9c",
      markerSize: 30,
      markerColor: "#12bf9c",
      transitionDuration: 1
    };
  }
  var _style = null;
  function getStyle(shouldRefresh = false) {
    return new Promise((resolve) => {
      if (_style === null || shouldRefresh) {
        _style = getDefaultStyle();
        const highlightStyleCheck = document.createElement("div");
        highlightStyleCheck.className = "Theme-Scrollpoints-Highlight";
        highlightStyleCheck.style.display = "none";
        highlightStyleCheck.style.pointerEvents = "none";
        document.body.appendChild(highlightStyleCheck);
        const markerStyleCheck = document.createElement("div");
        markerStyleCheck.className = "Theme-Scrollpoints-Marker";
        markerStyleCheck.style.display = "none";
        markerStyleCheck.style.pointerEvents = "none";
        document.body.appendChild(markerStyleCheck);
        setTimeout(() => {
          let computedStyle = window.getComputedStyle(markerStyleCheck);
          _style.markerSize = parseInt(computedStyle.getPropertyValue("width"), 10);
          _style.markerColor = computedStyle.getPropertyValue("background-color");
          computedStyle = window.getComputedStyle(highlightStyleCheck);
          _style.lineWidth = parseInt(computedStyle.getPropertyValue("border-width"), 10);
          _style.lineColor = computedStyle.getPropertyValue("border-color");
          _style.noHighlightsBehaviour = computedStyle.getPropertyValue("background-size") === "cover" ? "cover" : "contain";
          return resolve(_style);
        }, 50);
      } else {
        return resolve(_style);
      }
    });
  }
  function blur(context, amount) {
    if (amount <= 0)
      return;
    const { height, width } = context.canvas;
    const imageData = context.getImageData(0, 0, width, height);
    const { data } = imageData;
    const wm = width - 1;
    const hm = height - 1;
    const rad1 = amount + 1;
    const mulTable = [
      1,
      57,
      41,
      21,
      203,
      34,
      97,
      73,
      227,
      91,
      149,
      62,
      105,
      45,
      39,
      137,
      241,
      107,
      3,
      173,
      39,
      71,
      65,
      238,
      219,
      101,
      187,
      87,
      81,
      151,
      141,
      133,
      249,
      117,
      221,
      209,
      197,
      187,
      177,
      169,
      5,
      153,
      73,
      139,
      133,
      127,
      243,
      233,
      223,
      107,
      103,
      99,
      191,
      23,
      177,
      171,
      165,
      159,
      77,
      149,
      9,
      139,
      135,
      131,
      253,
      245,
      119,
      231,
      224,
      109,
      211,
      103,
      25,
      195,
      189,
      23,
      45,
      175,
      171,
      83,
      81,
      79,
      155,
      151,
      147,
      9,
      141,
      137,
      67,
      131,
      129,
      251,
      123,
      30,
      235,
      115,
      113,
      221,
      217,
      53,
      13,
      51,
      50,
      49,
      193,
      189,
      185,
      91,
      179,
      175,
      43,
      169,
      83,
      163,
      5,
      79,
      155,
      19,
      75,
      147,
      145,
      143,
      35,
      69,
      17,
      67,
      33,
      65,
      255,
      251,
      247,
      243,
      239,
      59,
      29,
      229,
      113,
      111,
      219,
      27,
      213,
      105,
      207,
      51,
      201,
      199,
      49,
      193,
      191,
      47,
      93,
      183,
      181,
      179,
      11,
      87,
      43,
      85,
      167,
      165,
      163,
      161,
      159,
      157,
      155,
      77,
      19,
      75,
      37,
      73,
      145,
      143,
      141,
      35,
      138,
      137,
      135,
      67,
      33,
      131,
      129,
      255,
      63,
      250,
      247,
      61,
      121,
      239,
      237,
      117,
      29,
      229,
      227,
      225,
      111,
      55,
      109,
      216,
      213,
      211,
      209,
      207,
      205,
      203,
      201,
      199,
      197,
      195,
      193,
      48,
      190,
      47,
      93,
      185,
      183,
      181,
      179,
      178,
      176,
      175,
      173,
      171,
      85,
      21,
      167,
      165,
      41,
      163,
      161,
      5,
      79,
      157,
      78,
      154,
      153,
      19,
      75,
      149,
      74,
      147,
      73,
      144,
      143,
      71,
      141,
      140,
      139,
      137,
      17,
      135,
      134,
      133,
      66,
      131,
      65,
      129,
      1
    ];
    const mulSum = mulTable[amount];
    const shgTable = [
      0,
      9,
      10,
      10,
      14,
      12,
      14,
      14,
      16,
      15,
      16,
      15,
      16,
      15,
      15,
      17,
      18,
      17,
      12,
      18,
      16,
      17,
      17,
      19,
      19,
      18,
      19,
      18,
      18,
      19,
      19,
      19,
      20,
      19,
      20,
      20,
      20,
      20,
      20,
      20,
      15,
      20,
      19,
      20,
      20,
      20,
      21,
      21,
      21,
      20,
      20,
      20,
      21,
      18,
      21,
      21,
      21,
      21,
      20,
      21,
      17,
      21,
      21,
      21,
      22,
      22,
      21,
      22,
      22,
      21,
      22,
      21,
      19,
      22,
      22,
      19,
      20,
      22,
      22,
      21,
      21,
      21,
      22,
      22,
      22,
      18,
      22,
      22,
      21,
      22,
      22,
      23,
      22,
      20,
      23,
      22,
      22,
      23,
      23,
      21,
      19,
      21,
      21,
      21,
      23,
      23,
      23,
      22,
      23,
      23,
      21,
      23,
      22,
      23,
      18,
      22,
      23,
      20,
      22,
      23,
      23,
      23,
      21,
      22,
      20,
      22,
      21,
      22,
      24,
      24,
      24,
      24,
      24,
      22,
      21,
      24,
      23,
      23,
      24,
      21,
      24,
      23,
      24,
      22,
      24,
      24,
      22,
      24,
      24,
      22,
      23,
      24,
      24,
      24,
      20,
      23,
      22,
      23,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      23,
      21,
      23,
      22,
      23,
      24,
      24,
      24,
      22,
      24,
      24,
      24,
      23,
      22,
      24,
      24,
      25,
      23,
      25,
      25,
      23,
      24,
      25,
      25,
      24,
      22,
      25,
      25,
      25,
      24,
      23,
      24,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      23,
      25,
      23,
      24,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      25,
      24,
      22,
      25,
      25,
      23,
      25,
      25,
      20,
      24,
      25,
      24,
      25,
      25,
      22,
      24,
      25,
      24,
      25,
      24,
      25,
      25,
      24,
      25,
      25,
      25,
      25,
      22,
      25,
      25,
      25,
      24,
      25,
      24,
      25,
      18
    ];
    const shgSum = shgTable[amount];
    const r = [];
    const g = [];
    const b = [];
    const a = [];
    const vmin = [];
    const vmax = [];
    let iterations = 3;
    let p, p1, p2, pa;
    while (iterations-- > 0) {
      let yw = 0;
      let yi = 0;
      for (let y = 0; y < height; y++) {
        let rsum = data[yw] * rad1;
        let gsum = data[yw + 1] * rad1;
        let bsum = data[yw + 2] * rad1;
        let asum = data[yw + 3] * rad1;
        for (let i = 1; i <= amount; i++) {
          p = yw + ((i > wm ? wm : i) << 2);
          rsum += data[p++];
          gsum += data[p++];
          bsum += data[p++];
          asum += data[p];
        }
        for (let x = 0; x < width; x++) {
          r[yi] = rsum;
          g[yi] = gsum;
          b[yi] = bsum;
          a[yi] = asum;
          if (y === 0) {
            vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
            vmax[x] = (p = x - amount) > 0 ? p << 2 : 0;
          }
          p1 = yw + vmin[x];
          p2 = yw + vmax[x];
          rsum += data[p1++] - data[p2++];
          gsum += data[p1++] - data[p2++];
          bsum += data[p1++] - data[p2++];
          asum += data[p1] - data[p2];
          yi++;
        }
        yw += width << 2;
      }
      for (let x = 0; x < width; x++) {
        let yp = x;
        let rsum = r[yp] * rad1;
        let gsum = g[yp] * rad1;
        let bsum = b[yp] * rad1;
        let asum = a[yp] * rad1;
        for (let i = 1; i <= amount; i++) {
          yp += i > hm ? 0 : width;
          rsum += r[yp];
          gsum += g[yp];
          bsum += b[yp];
          asum += a[yp];
        }
        yi = x << 2;
        for (let y = 0; y < height; y++) {
          data[yi + 3] = pa = asum * mulSum >>> shgSum;
          if (pa > 0) {
            pa = 255 / pa;
            data[yi] = (rsum * mulSum >>> shgSum) * pa;
            data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
            data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
          } else {
            data[yi] = data[yi + 1] = data[yi + 2] = 0;
          }
          if (x === 0) {
            vmin[y] = ((p = y + rad1) < hm ? p : hm) * width;
            vmax[y] = (p = y - amount) > 0 ? p * width : 0;
          }
          p1 = x + vmin[y];
          p2 = x + vmax[y];
          rsum += r[p1] - r[p2];
          gsum += g[p1] - g[p2];
          bsum += b[p1] - b[p2];
          asum += a[p1] - a[p2];
          yi += width << 2;
        }
      }
    }
    context.putImageData(imageData, 0, 0);
  }

  // ../story/src/scrollpoints/Tween.ts
  var Tween = class {
    constructor(onTick) {
      this.onTick = onTick;
    }
    start(from, to, duration) {
      this.from = round(from);
      this.to = round(to);
      this.duration = duration;
      if (isNaN(from.x) || isNaN(from.y) || isNaN(from.z) || isNaN(to.x) || isNaN(to.y) || isNaN(to.z))
        return;
      this.secondsRemaining = this.duration;
      this.lastTickAt = (/* @__PURE__ */ new Date()).getTime();
      this.tick = this.tick.bind(this);
      this.tick();
    }
    tick() {
      if (this.duration === 0) {
        this.onTick({
          x: this.to.x,
          y: this.to.y,
          z: this.to.z
        });
      } else {
        const now = (/* @__PURE__ */ new Date()).getTime();
        const secondsElapsed = (now - this.lastTickAt) / 1e3;
        this.lastTickAt = now;
        if (this.secondsRemaining > 0) {
          this.secondsRemaining = this.secondsRemaining - secondsElapsed;
          const percentage = 1 - Math.max(0, this.secondsRemaining) / this.duration;
          const eased = smoothStop(percentage);
          this.onTick({
            x: round(this.from.x + (this.to.x - this.from.x) * eased),
            y: round(this.from.y + (this.to.y - this.from.y) * eased),
            z: this.from.z + (this.to.z - this.from.z) * smoothStop(percentage)
          });
          requestAnimationFrame(this.tick);
        }
      }
    }
  };
  var smoothStop = (t) => 1 - (1 - t) * (1 - t);

  // ../story/src/scrollpoints/Camera.ts
  var MIN_ZOOM = 0.01;
  var MAX_ZOOM = 2.5;
  var Camera = class {
    constructor(canvas, image, backgroundColor, backgroundOpacity) {
      this.isHidden = false;
      this.pixelDensity = 1;
      // Cache canvas dimensions
      this.canvasWidth = 0;
      this.canvasHeight = 0;
      this.x = 0;
      this.y = 0;
      this.zoom = 1;
      this.noHighlightsBehaviour = "contain";
      this.maxX = 0;
      this.maxY = 0;
      this.setHighlightsAt = 0;
      this._style = getDefaultStyle();
      this._isReady = false;
      this._isRendering = false;
      if (typeof window.devicePixelRatio === "number") {
        this.pixelDensity = Math.min(2, window.devicePixelRatio);
      }
      this.canvas = canvas;
      this.initStyle().catch(console.error);
      this.offscreenCanvas = document.createElement("canvas");
      this.ctx = this.offscreenCanvas.getContext("2d", { alpha: false });
      this.ctx.imageSmoothingEnabled = true;
      this.finalCtx = this.canvas.getContext("2d", { alpha: false });
      this.image = image;
      this.highlights = [];
      this.backgroundColor = backgroundColor;
      this.backgroundOpacity = backgroundOpacity;
      this.bias = "none";
      this.x = 0;
      this.y = 0;
      this.zoom = 1;
      this.maxX = 0;
      this.maxY = 0;
      this.tween = new Tween(this.onTweenTick.bind(this));
      this._render = this._render.bind(this);
      this.render = this.render.bind(this);
      this.adjustSize();
      this._isReady = true;
      this.render();
    }
    initStyle() {
      return __async(this, null, function* () {
        this._computedStyle = getComputedStyle(this.canvas);
        this._style = yield getStyle(true);
      });
    }
    getColor(variable, fallback) {
      return variable ? this._computedStyle.getPropertyValue(`--${variable}`) : fallback;
    }
    hide() {
      this.isHidden = true;
      this.canvas.style.display = "none";
    }
    show() {
      if (this.isHidden) {
        this.render();
      }
      this.isHidden = false;
      this.canvas.style.display = "initial";
    }
    /**
     * Set the instant image url
     * @param src
     */
    setInstantSrc(src) {
      if (src === this.backgroundImageSrc)
        return;
      this.backgroundImageSrc = src;
      this.isBackgroundImageReady = false;
      if (!this.backgroundImage)
        this.backgroundImage = document.createElement("canvas");
      const image = document.createElement("img");
      image.crossOrigin = "use-credentials";
      image.addEventListener("load", () => {
        if (image.width <= 0)
          return;
        this.backgroundImage.width = 300;
        this.backgroundImage.height = 300;
        const ctx = this.backgroundImage.getContext("2d", { alpha: false });
        ctx.drawImage(image, 0, 0, this.backgroundImage.width, this.backgroundImage.height);
        blur(ctx, 10);
        this.isBackgroundImageReady = true;
      });
      image.src = src;
    }
    /**
     * Adjust the size of the canvas
     */
    adjustSize() {
      const { width } = this.canvas.parentElement.getBoundingClientRect();
      const height = window.innerHeight;
      this.canvas.width = width * this.pixelDensity;
      this.canvas.height = height * this.pixelDensity;
      this.canvas.style.width = `${width}px`;
      this.canvas.style.height = `${height}px`;
      this.canvasWidth = width * this.pixelDensity;
      this.canvasHeight = height * this.pixelDensity;
      this.offscreenCanvas.width = width * this.pixelDensity;
      this.offscreenCanvas.height = height * this.pixelDensity;
    }
    render() {
      if (this._isReady) {
        requestAnimationFrame(this._render);
      } else {
        requestAnimationFrame(this.render);
      }
    }
    _render(renderedAt) {
      if (this.isHidden)
        return;
      if (!this._isRendering) {
        this._isRendering = true;
        const frame = (renderedAt - this.setHighlightsAt) / 60;
        const ctx = this.ctx;
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        if (this.isBackgroundImageReady && this.backgroundImage.width > 0 && this.backgroundOpacity < 1) {
          ctx.drawImage(
            this.backgroundImage,
            0,
            0,
            this.backgroundImage.width,
            this.backgroundImage.height,
            0,
            0,
            this.canvasWidth,
            this.canvasHeight
          );
        }
        const darkenedHighlights = this.highlights.filter((h) => h.darkenAroundHighlight);
        if (darkenedHighlights.length > 0) {
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        }
        ctx.fillStyle = this.backgroundColor;
        ctx.globalAlpha = this.backgroundOpacity;
        ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        ctx.globalAlpha = 1;
        ctx.transform(this.zoom, 0, 0, this.zoom, round(this.canvasWidth / 2), round(this.canvasHeight / 2));
        if (this.image.width > 0) {
          ctx.drawImage(this.image, -this.x, -this.y);
        }
        const radii = 10 * this.pixelDensity / this.zoom;
        if (darkenedHighlights.length > 0) {
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
          ctx.transform(this.zoom, 0, 0, this.zoom, round(this.canvasWidth / 2), round(this.canvasHeight / 2));
          ctx.save();
          const path = new Path2D();
          darkenedHighlights.forEach((h) => {
            roundRect(path, -this.x + h.x, -this.y + h.y, h.width, h.height, radii);
          });
          ctx.clip(path);
          if (this.image.width > 0) {
            ctx.drawImage(this.image, -this.x, -this.y);
          }
          ctx.restore();
        }
        this.highlights.forEach((h) => {
          var _a;
          const path = new Path2D();
          ctx.lineWidth = round(this._style.lineWidth / 2 * this.pixelDensity / this.zoom);
          const effect = (_a = h.effect) != null ? _a : h.isHidden ? "hidden" : "solid";
          switch (effect) {
            case "hidden":
              break;
            case "ants":
              ctx.strokeStyle = this.getColor(h.color, this._style.lineColor);
              ctx.setLineDash([40 / this.zoom, 20 / this.zoom]);
              ctx.lineDashOffset = -(frame * 5 % 60) / this.zoom;
              roundRect(path, -this.x + h.x, -this.y + h.y, h.width, h.height, radii);
              ctx.stroke(path);
              break;
            case "draw":
              const perimeter = (h.width + h.height) * 2;
              ctx.strokeStyle = this.getColor(h.color, this._style.lineColor);
              ctx.setLineDash([perimeter]);
              ctx.lineDashOffset = Math.max(0, perimeter - frame * (perimeter / 60));
              roundRect(path, -this.x + h.x, -this.y + h.y, h.width, h.height, radii);
              ctx.stroke(path);
              break;
            case "flash":
              ctx.strokeStyle = this.getColor(h.color, this._style.lineColor);
              ctx.setLineDash([]);
              roundRect(path, -this.x + h.x, -this.y + h.y, h.width, h.height, radii);
              ctx.globalAlpha = (1 + Math.sin(frame / 4)) / 2;
              ctx.stroke(path);
              ctx.globalAlpha = 1;
              break;
            case "solid":
            default:
              ctx.strokeStyle = this.getColor(h.color, this._style.lineColor);
              ctx.setLineDash([]);
              roundRect(path, -this.x + h.x, -this.y + h.y, h.width, h.height, radii);
              ctx.stroke(path);
              break;
          }
          ctx.setLineDash([]);
          ctx.lineDashOffset = 0;
        });
        this.highlights.forEach((h) => {
          if (h.hasDot) {
            const radius = (this._style.markerSize / 2 - 2) * this.pixelDensity / this.zoom;
            const pulse = 2 * this.pixelDensity * ((1 + Math.sin(frame / 4)) / 2) / this.zoom;
            const circle = new Path2D();
            circle.arc(-this.x + h.dotX, -this.y + h.dotY, round(radius + pulse), 0, 2 * Math.PI);
            ctx.fillStyle = this.getColor(h.dotColor, this._style.lineColor);
            ctx.fill(circle);
            ctx.lineWidth = 4 * this.pixelDensity / this.zoom;
            ctx.strokeStyle = "black";
            ctx.stroke(circle);
          }
        });
        this.ctx.lineJoin = "round";
        this.ctx.lineCap = "square";
        this.highlights.forEach((h) => {
          const fontSize = 18 * this.pixelDensity - 4;
          ctx.font = `bold ${fontSize / this.zoom}px Arial`;
          ctx.textAlign = "center";
          ctx.fillStyle = "white";
          ctx.strokeStyle = "black";
          ctx.lineWidth = 6 * this.pixelDensity / this.zoom;
          if (h.label) {
            const x = this.ensureLabelXIsInsideBoundaries(ctx.measureText(h.label).width, -this.x + h.x + h.width * 0.5);
            ctx.strokeText(h.label, x, -this.y + h.y + h.height - (fontSize + 5) / this.zoom);
            ctx.fillText(h.label, x, -this.y + h.y + h.height - (fontSize + 5) / this.zoom);
          }
          if (h.dotLabel) {
            const x = this.ensureLabelXIsInsideBoundaries(ctx.measureText(h.dotLabel).width, -this.x + h.dotX);
            ctx.strokeText(h.dotLabel, x, -this.y + h.dotY - (fontSize + 10) / this.zoom);
            ctx.fillText(h.dotLabel, x, -this.y + h.dotY - (fontSize + 10) / this.zoom);
          }
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (this.offscreenCanvas.width > 0) {
          this.finalCtx.drawImage(this.offscreenCanvas, 0, 0);
        }
        this._isRendering = false;
      }
      this.render();
    }
    /**
     * The size of the image
     * @param width
     * @param height
     */
    setBounds(width, height) {
      this.maxX = width;
      this.maxY = height;
    }
    setHighlights(highlights, key) {
      var _a;
      this.noHighlightsBehaviour = this._style.noHighlightsBehaviour;
      this.highlights = [];
      let dimensions = this.getDimensions();
      let targetZoom = this.getAutoZoom(dimensions.width, dimensions.height);
      const duration = window["__prefersReducedMotion"] || ((_a = window.matchMedia("(prefers-reduced-motion: reduce)")) == null ? void 0 : _a.matches) ? 0 : this._style.transitionDuration;
      if (highlights.length > 0) {
        this.highlights = highlights.map((highlight) => {
          return __spreadProps(__spreadValues({}, highlight), {
            x: round(highlight.x / 100 * this.maxX),
            y: round(highlight.y / 100 * this.maxY),
            width: round(highlight.width / 100 * this.maxX),
            height: round(highlight.height / 100 * this.maxY),
            dotX: round(highlight.dotX / 100 * this.maxX),
            dotY: round(highlight.dotY / 100 * this.maxY)
          });
        });
        dimensions = this.getDimensions();
        targetZoom = this.getAutoZoom(dimensions.width, dimensions.height);
      }
      this.tween.start(
        { x: this.x, y: this.y, z: this.zoom },
        {
          x: dimensions.x + dimensions.width / 2,
          y: dimensions.y + dimensions.height / 2,
          z: targetZoom
        },
        key === this.key ? 0 : duration
      );
      this.key = key;
      this.setHighlightsAt = performance.now();
    }
    /**
     * Work out the full bounds of all highlight rects
     * @returns
     */
    getDimensions() {
      const dimensions = this.highlights.reduce(
        (d, rect) => {
          const nextDimensions = __spreadValues({}, d);
          if (nextDimensions.x === -1 || rect.x < nextDimensions.x) {
            nextDimensions.width = nextDimensions.x + nextDimensions.width - rect.x;
            nextDimensions.x = rect.x;
          }
          if (nextDimensions.y === -1 || rect.y < nextDimensions.y) {
            nextDimensions.height = nextDimensions.y + nextDimensions.height - rect.y;
            nextDimensions.y = rect.y;
          }
          if (rect.x + rect.width > nextDimensions.x + nextDimensions.width) {
            nextDimensions.width = rect.x - nextDimensions.x + rect.width;
          }
          if (rect.y + rect.height > nextDimensions.y + nextDimensions.height) {
            nextDimensions.height = rect.y - nextDimensions.y + rect.height;
          }
          return nextDimensions;
        },
        { x: -1, y: -1, width: 0, height: 0 }
      );
      if (this.highlights.length === 0) {
        dimensions.x = 0;
        dimensions.y = 0;
        dimensions.width = this.maxX;
        dimensions.height = this.maxY;
      }
      this.applyBias(dimensions);
      return dimensions;
    }
    /**
     * Apply camera biases to a given set of dimensions
     * @param dimensions
     */
    applyBias(dimensions) {
      if (display_container_default.getWidth() < 900)
        return;
      const isLandscape = dimensions.width > dimensions.height;
      if (this.bias === "left") {
        dimensions.width *= isLandscape ? 2.1 : 2.4;
      } else if (this.bias === "right") {
        dimensions.width *= isLandscape ? 2.1 : 2.4;
        dimensions.x -= dimensions.width / (isLandscape ? 1.9 : 1.7);
      }
    }
    /**
     * Get the best fit zoom for given width/height within the window
     * @param width
     * @param height
     */
    getAutoZoom(width, height) {
      if (typeof width === "undefined" || typeof height === "undefined") {
        width = this.maxX;
        height = this.maxY;
      }
      const showFullImage = width === this.maxX;
      const willContain = this.noHighlightsBehaviour === "contain" || this.highlights.length > 0;
      if (willContain) {
        width *= showFullImage ? 1.05 : 1.2;
        height *= showFullImage ? 1.05 : 1.2;
      }
      const widthRatio = this.canvasWidth / width;
      const heightRatio = this.canvasHeight / height;
      const z = willContain ? Math.min(heightRatio, widthRatio) : Math.max(heightRatio, widthRatio);
      return (0, import_clamp.default)(z, MIN_ZOOM, MAX_ZOOM);
    }
    /**
     * Set the zoom
     * @param zoom
     */
    setZoom(zoom) {
      if (typeof zoom === "undefined") {
        this.zoom = this.getAutoZoom();
      } else {
        this.zoom = zoom;
      }
      this.zoom = (0, import_clamp.default)(this.zoom, MIN_ZOOM, MAX_ZOOM);
      this.setCenter(this.x, this.y);
    }
    /**
     * Sets the camera center
     * @param x as percentage of full width
     * @param y as percentage of full width
     */
    setCenter(x, y) {
      if (typeof x !== "undefined") {
        this.x = round(x);
        this.y = round(y);
      } else {
        this.x = round(this.maxX / 2);
        this.y = round(this.maxY / 2);
      }
    }
    /**
     * Called on each tick of the Tween when the camera moves
     * @param value
     */
    onTweenTick(value) {
      if (isNaN(value.x) || isNaN(value.y) || isNaN(value.z))
        return;
      this.setCenter(value.x, value.y);
      this.setZoom(value.z);
    }
    /**
     * Check if a screen position is within one of the current highlights
     * @param position
     */
    hasHighlightAtScreenPosition(position) {
      const invertX = (x) => (x - this.x) * this.zoom + this.canvasWidth / 2;
      const invertY = (y) => (y - this.y) * this.zoom + this.canvasHeight / 2;
      return this.highlights.reduce((hasHighlight, h) => {
        if (hasHighlight)
          return true;
        if (position.x < invertX(h.x) || position.x > invertX(h.x + h.width))
          return false;
        if (position.y < invertY(h.y) || position.y > invertY(h.y + h.height))
          return false;
        return true;
      }, false);
    }
    /**
     * Take some text and an X coordinate and moves it if the text would be outside the borders
     * @param labelWidth The width of the text
     * @param x The initial X coordinate
     */
    ensureLabelXIsInsideBoundaries(labelWidth, x) {
      const dimensions = this.getDimensions();
      const minX = -this.x + dimensions.x;
      const maxX = minX + dimensions.width;
      if (x - labelWidth * 0.5 < minX) {
        x = minX + labelWidth * 0.5;
      } else if (x + labelWidth * 0.5 > maxX) {
        x = maxX - labelWidth * 0.5;
      }
      return x;
    }
  };
  function roundRect(path, x, y, width, height, radii) {
    if ("roundRect" in path) {
      path.roundRect(x, y, width, height, radii);
    } else {
      path.rect(x, y, width, height, radii);
    }
  }

  // ../story/src/scrollpoints/index.ts
  function initScrollpointsSections() {
    queryAll("[data-scrollpoints]").forEach((section) => initScrollpointsSection(section));
  }
  function initScrollpointsSection(section) {
    const mediaWrapper = section.querySelector("[data-media]");
    const canvas = document.createElement("canvas");
    mediaWrapper.appendChild(canvas);
    let previousActivePoint;
    let activePoint;
    const image = new Image();
    image.addEventListener("load", () => {
      camera.setBounds(image.naturalWidth, image.naturalHeight);
      camera.adjustSize();
      applyActivePoint(true);
    });
    image.src = mediaWrapper.getAttribute("data-media");
    canvas.setAttribute("role", "img");
    canvas.setAttribute("aria-label", mediaWrapper.getAttribute("data-alt-text"));
    const camera = new Camera(
      canvas,
      image,
      mediaWrapper.getAttribute("data-color"),
      parseFloat(mediaWrapper.getAttribute("data-opacity") || "10") / 100
    );
    camera.setInstantSrc(mediaWrapper.getAttribute("data-instant"));
    applyEditorEvents(section, canvas, camera);
    let scrollpoints = queryAll("[data-box]", section);
    camera.key = scrollpoints[0].getAttribute("data-item-id");
    function applyActivePoint(forceRender = false) {
      activePoint = getActivePoint(section);
      if (activePoint !== previousActivePoint || forceRender === true) {
        previousActivePoint = activePoint;
        if (!activePoint)
          return;
        applyCameraBias(activePoint, camera);
        const itemId = activePoint.getAttribute("data-item-id");
        if (itemId) {
          window.dispatchEvent(new CustomEvent("scrollpoint:active-point-changed", { detail: { itemId } }));
        }
        if (activePoint.getAttribute("data-box") === "") {
          camera.setHighlights([], itemId);
        } else {
          const { highlights } = JSON.parse(activePoint.getAttribute("data-box"));
          const boxes = highlights.map((box) => {
            return {
              x: parseFloat(box.x),
              y: parseFloat(box.y),
              width: parseFloat(box.width),
              height: parseFloat(box.height),
              effect: box.effect,
              color: box.color || "red",
              label: box.label || "",
              hasDot: !!box.hasDot,
              dotX: parseFloat(box.dotX),
              dotY: parseFloat(box.dotY),
              dotColor: box.dotColor,
              dotLabel: box.dotLabel || "",
              darkenAroundHighlight: box.darkenAroundHighlight || false
            };
          });
          camera.setHighlights(boxes, itemId);
        }
      }
    }
    function onScroll() {
      applyActivePoint();
      const { top, bottom } = section.getBoundingClientRect();
      if (top > display_container_default.getHeight() || bottom < display_container_default.getTop()) {
        camera.hide();
      } else {
        camera.show();
      }
    }
    let resizeDebounce = 0;
    function onResize() {
      clearTimeout(resizeDebounce);
      resizeDebounce = window.setTimeout(() => {
        camera.adjustSize();
        applyActivePoint(true);
      }, 200);
    }
    const scroller = document.getElementById("editor-viewport") || document;
    scroller.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", onResize, { passive: true });
    return () => {
      getStyle(true).catch(console.error);
      const nextSrc = mediaWrapper.getAttribute("data-media");
      if (image.src !== nextSrc) {
        image.src = nextSrc;
      }
      camera.setInstantSrc(mediaWrapper.getAttribute("data-instant"));
      scrollpoints = queryAll("[data-box]", section);
      camera.backgroundColor = mediaWrapper.getAttribute("data-color");
      camera.backgroundOpacity = parseFloat(mediaWrapper.getAttribute("data-opacity")) / 100;
      applyActivePoint(true);
    };
  }
  function applyEditorEvents(section, canvas, camera) {
    if (!document.getElementById("editor-viewport"))
      return;
    const sectionId = section.getAttribute("data-section-id");
    canvas.addEventListener(
      "mousemove",
      (e) => {
        if (camera.hasHighlightAtScreenPosition({ x: e.offsetX, y: e.offsetY })) {
          document.body.style.setProperty("cursor", "zoom-in");
        } else {
          document.body.style.setProperty("cursor", "auto");
        }
      },
      { passive: true }
    );
    canvas.addEventListener("click", (e) => {
      if (camera.hasHighlightAtScreenPosition({ x: e.offsetX, y: e.offsetY })) {
        const activePoint = getActivePoint(section);
        window.dispatchEvent(
          new CustomEvent("scrollpoint:manage-highlights", {
            detail: {
              sectionId,
              activeItemId: activePoint.getAttribute("data-item-id")
            }
          })
        );
      }
    });
  }
  function getActivePoint(section) {
    const THRESHOLD = window.innerHeight * 0.9;
    const mediaWrapper = section.querySelector("[data-media]");
    const scrollpoints = queryAll("[data-box]", section);
    let activePoint;
    const sectionBounds = section.getBoundingClientRect();
    if (sectionBounds.bottom < display_container_default.getTop() + display_container_default.getHeight()) {
      activePoint = scrollpoints[scrollpoints.length - 1];
      mediaWrapper.setAttribute("data-attach", "after");
    } else if (sectionBounds.top < display_container_default.getTop()) {
      activePoint = scrollpoints.reduce((active, point) => {
        const bounds = point.getBoundingClientRect();
        if (bounds.top < THRESHOLD) {
          return point;
        } else
          return active;
      }, scrollpoints[0]);
      mediaWrapper.setAttribute("data-attach", "during");
    } else {
      activePoint = scrollpoints[0];
      mediaWrapper.setAttribute("data-attach", "before");
    }
    return activePoint;
  }
  function applyCameraBias(activePoint, camera) {
    switch (activePoint.getAttribute("data-align")) {
      case "left":
        camera.bias = "right";
        break;
      case "right":
        camera.bias = "left";
        break;
      default:
        camera.bias = "none";
    }
  }

  // ../story/src/scrollpoints.entry.js
  initScrollpointsSections();
})();
/*! Bundled license information:

classnames/dedupe.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=scrollpoints.local.min.js.map
